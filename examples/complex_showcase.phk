// Protohack orchestration example â€“ full file encryption pipeline with metrics

const JOB_COUNT = 3;

craft job_label(index as num) gives text {
    if (index == 0) {
        yield "alpha";
    }
    if (index == 1) {
        yield "beta";
    }
    if (index == 2) {
        yield "gamma";
    }
    yield "job-" + to_string(index);
}

craft job_input(index as num) gives text {
    if (index == 0) {
        yield "samples/alpha.txt";
    }
    if (index == 1) {
        yield "samples/beta.txt";
    }
    if (index == 2) {
        yield "samples/gamma.txt";
    }
    yield "samples/job-" + to_string(index) + ".txt";
}

craft job_cipher(index as num) gives text {
    yield job_input(index) + ".enc";
}

craft job_recovered(index as num) gives text {
    yield job_input(index) + ".dec";
}

craft job_manual_key(index as num) gives text {
    if (index == 1) {
        yield "cafebabecafebabecafebabecafebabe";
    }
    yield "";
}

craft request_operator_key(label as text, fallback as text) gives text {
    let prompt = "[" + label + "] Enter encryption key";
    if (len(fallback) > 0) {
        prompt = prompt + " (hex, leave blank to use preset)";
    } else {
        prompt = prompt + " (hex, leave blank for random)";
    }
    prompt = prompt + ": ";

    let input = read_line(prompt);
    if (input == null) {
        yield fallback;
    }
    if (len(input) > 0) {
        yield input;
    }
    yield fallback;
}

craft compute_summary(lengths as numeric, count as num) gives text {
    if (count <= 0) {
        yield "no encryption runs recorded";
    }

    let idx = 0;
    let total = 0;
    let minimum = probe numeric(lengths, 0);
    let maximum = minimum;

    while (idx < count) {
        let length = probe numeric(lengths, idx);
        total = total + length;
        if (length < minimum) {
            minimum = length;
        }
        if (length > maximum) {
            maximum = length;
        }
        idx = idx + 1;
    }

    let average = total / count;
    let report = "min=" + to_string(minimum) + ", max=" + to_string(maximum) + ", avg=" + to_string(average);
    yield report;
}

class CipherMonitor {
    init(batch as num) {
        this.count = batch;
        this.key_lengths = carve numeric(batch);
        this.total_runs = 0;
    }

    record(run as num, key as text) {
        let length = len(key);
        let buffer = this.key_lengths;
        etch numeric(buffer, run, length);
        this.total_runs = this.total_runs + 1;
    }

    summary() gives text {
        yield compute_summary(this.key_lengths, this.count);
    }
}

craft announce_job(label as text, plain as text, cipher as text, recovered as text) gives text {
    yield "[" + label + "] " + plain + " -> " + cipher + " (restore: " + recovered + ")";
}

println("==============================");
println("Protohack secure vault orchestrator");
println("==============================\n");

println("This script assumes the source files exist inside the samples/ directory.\n" +
    "Each job encrypts a different payload, stores the key, and then restores the plaintext.");

let monitor = CipherMonitor(JOB_COUNT);

let job = 0;
while (job < JOB_COUNT) {
    let label = job_label(job);
    let plain_path = job_input(job);
    let cipher_path = job_cipher(job);
    let recovered_path = job_recovered(job);
    let manual_key = job_manual_key(job);

    println("----");
    println(announce_job(label, plain_path, cipher_path, recovered_path));

    let operator_key = request_operator_key(label, manual_key);

    let key = null;
    if (len(operator_key) > 0) {
        println("Encrypting with operator-provided key.");
        key = encrypt_file(plain_path, cipher_path, operator_key);
    } else {
        println("Generating random key for job " + label + ".");
        key = encrypt_file(plain_path, cipher_path);
    }

    println("Key material (" + to_string(len(key)) + " hex chars): " + key);
    monitor.record(job, key);

    println("Decrypting immediately to verify integrity...");
    decrypt_file(cipher_path, recovered_path, key);
    println("Restored file written to " + recovered_path + ".\n");

    job = job + 1;
}

println("==============================");
println("Vault summary");
println("==============================");
println("Total jobs executed: " + to_string(monitor.total_runs));
println("Key length stats: " + monitor.summary());
println("==============================");
